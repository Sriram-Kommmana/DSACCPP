/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int solve(TreeNode* root, int& diameter){
        if(root == NULL) return 0;

        int left = solve(root -> left, diameter);
        int right = solve(root -> right, diameter);
        diameter = max(diameter, left + right);

        return diameter + 1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        int diameter = 0;
        int ans = solve(root, diameter);
        return ans;
    }
};


//in leetcode the diameter is the max lenght between 2 nodes, but in gfg it is the max nodes between 2 nodes ---> this was previously
// now they updated the question in gfg. so the above ans is correct absolutely

// the below ans was for gfg previously.
--------------------------------------------------------------------------------------------------------------------------------------------

pair<int,int> diameterFast(Node* root) {
    //base case
    if(root == NULL) {
        pair<int,int> p = make_pair(0,0);
        return p;
    }
    
    pair<int,int> left = diameterFast(root->left);
    pair<int,int> right = diameterFast(root->right);
    
    int op1 = left.first;
    int op2 = right.first;
    int op3 = left.second + right.second + 1;
    
    pair<int,int> ans;
    ans.first = max(op1, max(op2, op3));;
    ans.second = max(left.second , right.second) + 1;

    return ans;
}
int diameter(Node* root) {

    return diameterFast(root).first;
    
}




// if you want to pass all the test cases now on gfg the you have to do a slight modification in top3 i.e. you have to remove + 1 as we are not considering the number of nodes but we are considenring the path
// here is the updated answer given below which is correct in both leetcode and gfg
-----------------------------------------------------------------------------------------------------------------------------



/*
class Node {
public:
    int data;
    Node* left;
    Node* right;

    Node(int val) {
        data = val;
        left = NULL;
        right = NULL;
    }
};

Node* newNode(int val) {
    return new Node(val);
}
*/
pair<int,int> diameterFast(Node* root) {
    //base case
    if(root == NULL) {
        pair<int,int> p = make_pair(0,0);
        return p;
    }
    
    pair<int,int> left = diameterFast(root->left);
    pair<int,int> right = diameterFast(root->right);
    
    int op1 = left.first;
    int op2 = right.first;
    int op3 = left.second + right.second;
    
    pair<int,int> ans;
    ans.first = max(op1, max(op2, op3));;
    ans.second = max(left.second , right.second) + 1;

    return ans;
}

class Solution {
  public:
    int diameter(Node* root) {
        // Your code here
        return diameterFast(root).first;
    }
};
